<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head>
<!--
----	(c) Copyright 2002-2010 by Lutz Sammer, Russell Smith

----    This program is free software; you can redistribute it and/or modify
----    it under the terms of the GNU General Public License as published by
----    the Free Software Foundation; only version 2 of the License.
----
----    This program is distributed in the hope that it will be useful,
----    but WITHOUT ANY WARRANTY; without even the implied warranty of
----    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
----    GNU General Public License for more details.
----
----    You should have received a copy of the GNU General Public License
----    along with this program; if not, write to the Free Software
----    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
----    02111-1307, USA.
-->
    <title>Bos Wars Scripting API: User Interface (UI)</title>
    <meta http-equiv="Content-Type" content="text/html; CHARSET=iso-8859-1">
</head>
<body>
    <h1>Bos Wars Scripting API: User Interface (UI)</h1>
<hr>
<a href="../index.html">Bos Wars</a>
<a href="../faq.html">FAQ</a>
<a href="triggers.html">PREV</a>
<a href="unittype.html">NEXT</a>
<a href="index.html">LUA Index</a>
<hr>
<a href="#CColor">CColor</a>
<a href="#CFontColor">CFontColor</a>
<a href="#DefineButton">DefineButton</a>
<a href="#DefineButtonStyle">DefineButtonStyle</a>
<a href="#DefineCursor">DefineCursor</a>
<a href="#DefineViewports">DefineViewports</a>
<a href="#MaxFontColors">MaxFontColors</a>
<a href="#SetGameCursor">SetGameCursor</a>
<a href="#text_formatting">text formatting</a>
<a href="#UI">UI</a>
<hr>
<h2>Intro - Introduction to UI functions and variables</h2>

Everything around the user interface.

<h2>Conceptual</h2>

<a name="text_formatting"></a>
<h3>Text formatting</h3>

<p>When the engine displays text on the screen, it recognizes the
following format codes.</p>

<dl>
  <dt>"~~"</dt>
  <dd>Displays a single "~" character.</dd>
  <dt>"~!"</dt>
  <dd>Marks the following character as a hot key
    and draws it in a different color,
    usually <a href="#UI.ReverseFontColor">UI.ReverseFontColor</a>.
    Highlighting works even in those widgets that do not support hot
    keys.</dd>
  <dt>"~&lt;" and "~&gt;"</dt>
  <dd>Marks the text between these strings as a hot key and draws it
    in a different color.  Use this if the name of the hot key is
    multiple characters long, e.g. "Cancel (~&lt;Esc~&gt;)"
    or "Help (~&lt;F1~&gt;)".  If a translation to another language
    changes the name of the Esc key, then the engine will recognize
    both the "Esc" name and the translated name as referring to that
    key.</dd>
  <dt>"~<var>color</var>~" and "~&gt;"</dt>
  <dd>Displays the text between these strings with the specified
    color, if such a color name has been defined with 
    <a href="#CFontColor.New">CFontColor:New</a>.
    For example, "the ~red~original~&gt; sin" would display
    "the original sin", where "original" would be red.</dd>
</dl>

<h2>Functions</h2>

<a name="DefineButton"></a>
<h3>DefineButton({tag1 = value1, tag2 value2, ...})</h3>

Define a button in the button panel show during the game. Possible tags:

<dl>
<dt>Pos = number</dt>
<dd>Position number.
<pre>
0 1 2
3 4 5
6 7 8
</pre>
</dd>
<dt>Level = number</dt>
<dd>Visible when in this button level (0 default, 9 cancel-only)
</dd>
<dt>Icon = "icon-name"</dt>
<dd>Name of the icon to display.
</dd>
<dt>Action = "action"</dt>
<dd>Action to perform when the button is clicked.  Can be any of the following:
<dl>
  <dt>"move"</dt>
  <dd>The unit moves to location</dd>
  <dt>"stop"</dt>
  <dd>the unit stops. Orders queue is also erased. The unit wait for order but can react by itself.</dd>
  <dt>"attack"</dt>
  <dd>The unit attacks target. if target is a unit then it attacks only the unit.
If target is a position, it will move to location by attacking any opponent on the way.</dd>
  <dt>"repair"</dt>
  <dd>The unit will repair the target unit.</dd>
  <dt>"harvest"</dt>
  <dd>The unit will harvest the ressources.</dd>
  <dt>"button"</dt>
  <dd>FIXME. Need Value = number.</dd>
  <dt>"build"</dt>
  <dd>The unit will build the unit (building structure)</dd>
  <dt>"train-unit"</dt>
  <dd>The unit trains an unit. Generally use for building to create news units.
Need Value = "unit-name".</dd>
  <dt>"patrol"</dt>
  <dd>The unit patrol between target position and current position and attack any opponent
on the way.</dd>
  <dt>"stand-ground"</dt>
  <dd>The unit doesn't move. The unit stay at its location until it receives a new order.</dd>
  <dt>"attack-ground"</dt>
  <dd>The unit attack a location. Usefull for unit with spalsh damage.</dd>
  <dt>"cast-spell"</dt>
  <dd>The unit cast a spell.
Need Value = "spell-name"</dd>
  <dt>"unload"</dt>
  <dd>The unit unload unit inside of itself. Usefull for transporter or bunkers.</dd>
  <dt>"cancel"</dt>
  <dd>FIXME : difference between cancels.</dd>
  <dt>"cancel-train-unit"</dt>
  <dd>FIXME</dd>
  <dt>"cancel-build"</dt>
  <dd>FIXME</dd>
  </dl>
  </dd>
<dt>Value = arg</dt>
<dd>Optional value associated with the action.
</dd>
<dt>Allowed = "check-name"</dt>
<dd>Optional check to see if a button is allowed. Can be any of the following:
  <dl>
  <dt>"check-true"</dt>
  <dd>No restriction on this button.</dd>
  <dt>"check-false"</dt>
  <dd>this button is forbidden. FIXME : ? to be removed. What is its usage ?</dd>
  <dt>"check-units-or"</dt>
  <dd>this button is available if at least one of the unit are available.
  Need AllowArg = {"unit-name1", "unit-name2"}</dd>
  <dt>"check-units-and"</dt>
  <dd>FIXME</dd>
  <dt>"check-network"</dt>
  <dd>Button is available only if network is available too.</dd>
  <dt>"check-no-network"</dt>
  <dd>Button is available only if network is not available.</dd>
  <dt>"check-no-work"</dt>
  <dd>FIXME</dd>
  <dt>"check-attack"</dt>
  <dd>FIXME</dd>
  </dl>
</dd>
<dt>AllowArg = {"arg1", ...}</dt>
<dd>Optional argument used by the allowed function.
</dd>
<dt>Hint = "string"</dt>
<dd>Hint to be displayed for the button.  To define a shortcut key
for the button, use the "~!", "~&lt;", and "~&gt;" format codes
described in <a href="#text_formatting">Text formatting</a>.
</dd>
<dt>ForUnit = {"unit-name1", ...} or {"*"} </dt>
<dd>List of units the button applies to, or {"*"} for all units.
</dd>
</dl>

<h4>Example</h4>
<pre>
DefineButton( { Pos = 8, Level = 0, Icon = "icon-build-advanced",
  Action = "button", Value = 2,
  Allowed = "check-units-or", AllowArg = {"unit-elven-lumber-mill", "unit-keep"},
  Hint = "BUILD AD~!VANCED STRUCTURE",
  ForUnit = {"unit-peasant"} } )
</pre>

<a name="DefineButtonStyle"></a>
<h3>DefineButtonStyle(style, {tag = value, ...})</h3>

Define a button style. Possible tags:

<dl>
<dt>Size = {x, y}</dt>
<dd>Size of the button.
</dd>
<dt>Font = font-name</dt>
<dd>Name of the font to use.
</dd>
<dt>TextNormalColor = color, TextReverseColor = color</dt>
<dd>Color to use for the normal and reverse text.
</dd>
<dt>TextAlign = align</dt>
<dd>Align the text.  Possible values are "Left", "Right", and "Center".
</dd>
<dt>TextPos = {posx, posy}</dt>
<dd>Set the position of the text relative to the upper left corner of the image.
</dd>
<dt>Default = {tag = value, ...}, Hover = {}, Selected = {}, Clicked = {}, Disabled = {}</dt>
<dd>Set attributes for when the mouse is over the button (Hover), the button is
Selected, Clicked, Disabled, or the Default setting. Possible tags:
  <dl>
  <dt>File = file</dt>
  <dd>The filename.
  </dd>
  <dt>Size = size</dt>
  <dd>The size of the image (only needed when using an image with multiple frames).
  </dd>
  <dt>Frame = frame</dt>
  <dd>Select the frame number from an image (only needed when using an image with multiple frames).
  </dd>
  <dt>TextNormalColor = color, TextReverseColor = color</dt>
  <dd>Color to use for the normal and reverse text (overrides the main colors).
  </dd>
  <dt>TextPos = {x, y}</dt>
  <dd>Display the text at this position (overrides the main position).
  </dd>
  <dt>Border = { Color = color, Size = size}</dt>
  <dd>Draw a border with the specified color and size.
  </dd>
  </dl>
</dd>
</dl>

<h4>Example</h4>
<pre>
DefineButtonStyle("main", {
  Size = {128, 20},
  Font = "game",
  TextNormalColor = "yellow",
  TextReverseColor = "white",
  TextAlign = "Center",
  TextPos = {64, 4},
  Default = {
    File = "ui/buttons_1.png", Size = {300, 144}, Frame = 4,
  },
  Hover = {
    TextNormalColor = "white",
  },
  Selected = {
    Border = {
      Color = {252, 252, 0}, Size = 1,
    },
  },
  Clicked = {
    File = "ui/buttons_1.png", Size = {300, 144}, Frame = 5,
    TextNormalColor = "white",
    TextPos = {66, 6},
  },
  Disabled = {
    File = "ui/buttons_1.png", Size = {300, 144}, Frame = 3,
    TextNormalColor = "grey",
    TextReverseColor = "grey",
  },
})
</pre>

<a name="DefineCursor"></a>
<h3>DefineCursor({tag = value, ...})</h3>

Define a cursor.

<dl>
<dt>Name = "ident"</dt>
<dd>Unique identifier of the cursor, used to reference it in config files and
during startup.
</dd>
<dt>Race = "race-name" or "any"</dt>
<dd>Race to use this cursor with or "any" to use with any race.
</dd>
</dl>
Possible tags:
<dl>
<dt>File = "icon-file"</dt>
<dd>Path to the image graphic.</dd>
<dt>HotSpot = {x, y}</dt>
<dd>Hot spot of the cursor in pixels. Relative to the sprite origin {0, 0}. The
hot spot of a cursor is the point to which Bos Wars refers in tracking the
cursor's position.
</dd>
<dt>Size = {width, height}</dt>
<dd>Size of the cursor in pixels.</dd>
<dt>Rate = millisecond</dt>
<dd>Rate of changing the frames if using an animated cursor. The "rate" tells
the engine how many milliseconds to hold each frame of the animation.
</dd>
</dl>

Note: Name, File and Size must be filled.

<h4>Example</h4>
<pre>
DefineCursor({
  Name = "cursor-cross",
  Race = "any",
  File = "ui/cursors/small_green_cross.png",
  HotSpot = {8,  8},
  Size = {18, 18}})
</pre>

<a name="DefineViewports"></a>
<h3>DefineViewports("mode", mode, "viewport", {mapx, mapy}, ...)</h3>

Define the viewports. Only used in savegames, but could be useful for
scenarios.

<dl>
<dt>"mode", number</dt>
<dd>Number corresponding to the viewport mode.  See the ViewportMode enum. FIXME</dd>
<dt>"viewport", {mapx, mapy}</dt>
<dd>X, Y coordinate of the map tile.
</dd>
</dl>

<h4>Example</h4>
<pre>
-- Defines the viewports to use mode 1 (split horizontal) with the first
-- viewport having map coordinates 82,31 and the second having coordinates 64,31.
DefineViewports("mode", 1, "viewport", {82, 31},
                           "viewport", {64, 31})
</pre>

<a name="SetGameCursor"></a>
<h3>SetGameCursor("cursor-ident")</h3>
Set the game cursor.
<dl>
<dt>"cursor-ident"</dt>
<dd>Unique identifier of the cursor.</dd>
</dl>

<h4>Example</h4>
<pre>
-- Set the game cursor to 'cursor-point'.
SetGameCursor("cursor-point")
</pre>

<h2>Variables</h2>

<a name="UI"></a>
<h3>UI</h3>

<p>This variable refers to an object that has at least the following properties:</p>

<dl>
  <dt>UI.ButtonPanel.ShowCommandKey = boolean</dt>
  <dd>Enable/disable the display of the command keys in buttons.</dd>
  <dt id="UI.ReverseFontColor">UI.ReverseFontColor = string</dt>
  <dd>The name of the font color generally used for highlighting
    in <a href="#text_formatting">text formatting</a>.
    The font color must be defined with
    <a href="#CFontColor.New">CFontColor:New</a>.</dd>
</dl>

<p>Do not change the UI variable itself from Lua, even though the
engine may allow that.</p>

<h2>Types</h2>

<a name="CColor"></a>
<h3>CColor</h3>

<p>The CColor type represents an RGBA color.</p>

<p>In the following subsections, <var>color</var> denotes an object of
type CColor.</p>

<h4>CColor([r], [g], [b], [a])</h4>

<p>Constructs a <a href="#CColor">CColor</a> object with the
specified Red, Green, Blue, and Alpha component values.
All arguments are optional.</p>

<h4><var>color</var>:R</h4>

<p>The red component, between 0 and 255.</p>

<h4><var>color</var>:G</h4>

<p>The green component, between 0 and 255.</p>

<h4><var>color</var>:B</h4>

<p>The blue component, between 0 and 255.</p>

<h4><var>color</var>:A</h4>

<p>The alpha component, between 0 and 255.
Not premultiplied.</p>

<p>Currently, the engine ignores the alpha component
of all CColor objects that Lua code can access:</p>

<ul>
  <li><a href="#CFontColor.Colors"><var>fontColor</var>:Colors</a></li>
  <li>UI:ButtonPanel:AutoCastBorderColorRGB</li>
  <li>UI:CompletedBarColorRGB</li>
</ul>

<a name="CFontColor"></a>
<h3>CFontColor</h3>

<p>Each CFontColor object represents a named set of colors for use
in <a href="#text_formatting">text formatting</a>.</p>

<p>In the following subsections, <var>fontColor</var> denotes an
object of type CFontColor.</p>

<h4 id="CFontColor.Colors"><var>fontColor</var>:Colors</h4>

<p>An array of <a href="#CColor">CColor</a> objects.
There are <a href="#MaxFontColors">MaxFontColors</a> elements in the array.
The engine ignores the alpha component of these CColor objects.</p>

<h4 id="CFontColor.Get">CFontColor:Get("name")</h4>

<p>Finds a font color by name.
Returns a <a href="#CFontColor">CFontColor</a> object if found.
If no such font color has been defined, which indicates a bug,
then this function returns nil instead.</p>

<h4 id="CFontColor.New">CFontColor:New("name")</h4>

<p>Finds a font color by name, or allocates a new one.
Returns a <a href="#CFontColor">CFontColor</a> object.
If it is a new one, then its <a href="#CFontColor.Colors">Colors</a>
array is all black, so you should set that before you use the
font color in <a href="#text_formatting">text formatting</a>.</p>

<a name="MaxFontColors"></a>
<h4>MaxFontColors</h4>

<p>This constant integer is the number of elements in the
<a href="#CFontColor.Colors">Colors</a> array in CFontColor
objects.</p>

<hr>
All trademarks and copyrights on this page are owned by their respective owners.
<address>(c) 2002-2010 by <a href="http://boswars.org">
The Bos Wars Project</a></address></body></html>

