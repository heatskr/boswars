<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head>
<!--
----	(c) Copyright 2002-2010 by Lutz Sammer, Russell Smith

----    This program is free software; you can redistribute it and/or modify
----    it under the terms of the GNU General Public License as published by
----    the Free Software Foundation; only version 2 of the License.
----
----    This program is distributed in the hope that it will be useful,
----    but WITHOUT ANY WARRANTY; without even the implied warranty of
----    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
----    GNU General Public License for more details.
----
----    You should have received a copy of the GNU General Public License
----    along with this program; if not, write to the Free Software
----    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
----    02111-1307, USA.
-->
    <title>Bos Wars Scripting API: User Interface (UI)</title>
    <meta http-equiv="Content-Type" content="text/html; CHARSET=iso-8859-1">
</head>
<body>
    <h1>Bos Wars Scripting API: User Interface (UI)</h1>
<hr>
<a href="../index.html">Bos Wars</a>
<a href="../faq.html">FAQ</a>
<a href="triggers.html">PREV</a>
<a href="unittype.html">NEXT</a>
<a href="index.html">LUA Index</a>
<hr>
<a href="#CColor">CColor</a>
<a href="#CFontColor">CFontColor</a>
<a href="#CGraphic">CGraphic</a>
<a href="#CResourceInfo">CResourceInfo</a>
<a href="#DefineButton">DefineButton</a>
<a href="#DefineButtonStyle">DefineButtonStyle</a>
<a href="#DefineCursor">DefineCursor</a>
<a href="#DefineViewports">DefineViewports</a>
<a href="#HandleCommandKey">HandleCommandKey</a>
<a href="#MaxFontColors">MaxFontColors</a>
<a href="#SetGameCursor">SetGameCursor</a>
<a href="#text_formatting">text formatting</a>
<a href="#UI">UI</a>
<hr>
<h2>Intro - Introduction to UI functions and variables</h2>

Everything around the user interface.

<h2>Conceptual</h2>

<a name="text_formatting"></a>
<h3>Text formatting</h3>

<p>When the engine displays text on the screen, it recognizes the
following format codes.</p>

<dl>
  <dt>"~~"</dt>
  <dd>Displays a single "~" character.</dd>
  <dt>"~!"</dt>
  <dd>Marks the following character as a hot key
    and draws it in a different color,
    usually <a href="#UI.ReverseFontColor">UI.ReverseFontColor</a>.
    Highlighting works even in those widgets that do not support hot
    keys.</dd>
  <dt>"~&lt;" and "~&gt;"</dt>
  <dd>Marks the text between these strings as a hot key and draws it
    in a different color.  Use this if the name of the hot key is
    multiple characters long, e.g. "Cancel (~&lt;Esc~&gt;)"
    or "Help (~&lt;F1~&gt;)".  If a translation to another language
    changes the name of the Esc key, then the engine will recognize
    both the "Esc" name and the translated name as referring to that
    key.</dd>
  <dt>"~<var>color</var>~" and "~&gt;"</dt>
  <dd>Displays the text between these strings with the specified
    color, if such a color name has been defined with 
    <a href="#CFontColor.New">CFontColor:New</a>.
    For example, "the ~red~original~&gt; sin" would display
    "the original sin", where "original" would be red.</dd>
</dl>

<h2>Functions</h2>

<a name="DefineButton"></a>
<h3>DefineButton({tag1 = value1, tag2 value2, ...})</h3>

Define a button in the button panel show during the game. Possible tags:

<dl>
<dt>Pos = number</dt>
<dd>Position number.
<pre>
0 1 2
3 4 5
6 7 8
</pre>
</dd>
<dt>Level = number</dt>
<dd>Visible when in this button level (0 default, 9 cancel-only)
</dd>
<dt>Icon = "icon-name"</dt>
<dd>Name of the icon to display.
</dd>
<dt>Action = "action"</dt>
<dd>Action to perform when the button is clicked.  Can be any of the following:
<dl>
  <dt>"move"</dt>
  <dd>The unit moves to location</dd>
  <dt>"stop"</dt>
  <dd>the unit stops. Orders queue is also erased. The unit wait for order but can react by itself.</dd>
  <dt>"attack"</dt>
  <dd>The unit attacks target. if target is a unit then it attacks only the unit.
If target is a position, it will move to location by attacking any opponent on the way.</dd>
  <dt>"repair"</dt>
  <dd>The unit will repair the target unit.</dd>
  <dt>"harvest"</dt>
  <dd>The unit will harvest the ressources.</dd>
  <dt>"button"</dt>
  <dd>FIXME. Need Value = number.</dd>
  <dt>"build"</dt>
  <dd>The unit will build the unit (building structure)</dd>
  <dt>"train-unit"</dt>
  <dd>The unit trains an unit. Generally use for building to create news units.
Need Value = "unit-name".</dd>
  <dt>"patrol"</dt>
  <dd>The unit patrol between target position and current position and attack any opponent
on the way.</dd>
  <dt>"stand-ground"</dt>
  <dd>The unit doesn't move. The unit stay at its location until it receives a new order.</dd>
  <dt>"attack-ground"</dt>
  <dd>The unit attack a location. Usefull for unit with spalsh damage.</dd>
  <dt>"cast-spell"</dt>
  <dd>The unit cast a spell.
Need Value = "spell-name"</dd>
  <dt>"unload"</dt>
  <dd>The unit unload unit inside of itself. Usefull for transporter or bunkers.</dd>
  <dt>"cancel"</dt>
  <dd>FIXME : difference between cancels.</dd>
  <dt>"cancel-train-unit"</dt>
  <dd>FIXME</dd>
  <dt>"cancel-build"</dt>
  <dd>FIXME</dd>
  </dl>
  </dd>
<dt>Value = arg</dt>
<dd>Optional value associated with the action.
</dd>
<dt>Allowed = "check-name"</dt>
<dd>Optional check to see if a button is allowed. Can be any of the following:
  <dl>
  <dt>"check-true"</dt>
  <dd>No restriction on this button.</dd>
  <dt>"check-false"</dt>
  <dd>this button is forbidden. FIXME : ? to be removed. What is its usage ?</dd>
  <dt>"check-units-or"</dt>
  <dd>this button is available if at least one of the unit are available.
  Need AllowArg = {"unit-name1", "unit-name2"}</dd>
  <dt>"check-units-and"</dt>
  <dd>FIXME</dd>
  <dt>"check-network"</dt>
  <dd>Button is available only if network is available too.</dd>
  <dt>"check-no-network"</dt>
  <dd>Button is available only if network is not available.</dd>
  <dt>"check-no-work"</dt>
  <dd>FIXME</dd>
  <dt>"check-attack"</dt>
  <dd>FIXME</dd>
  </dl>
</dd>
<dt>AllowArg = {"arg1", ...}</dt>
<dd>Optional argument used by the allowed function.
</dd>
<dt>Hint = "string"</dt>
<dd>Hint to be displayed for the button.  To define a shortcut key
for the button, use the "~!", "~&lt;", and "~&gt;" format codes
described in <a href="#text_formatting">Text formatting</a>.
</dd>
<dt>ForUnit = {"unit-name1", ...} or {"*"} </dt>
<dd>List of units the button applies to, or {"*"} for all units.
</dd>
</dl>

<h4>Example</h4>
<pre>
DefineButton( { Pos = 8, Level = 0, Icon = "icon-build-advanced",
  Action = "button", Value = 2,
  Allowed = "check-units-or", AllowArg = {"unit-elven-lumber-mill", "unit-keep"},
  Hint = "BUILD AD~!VANCED STRUCTURE",
  ForUnit = {"unit-peasant"} } )
</pre>

<a name="DefineButtonStyle"></a>
<h3>DefineButtonStyle(style, {tag = value, ...})</h3>

Define a button style. Possible tags:

<dl>
<dt>Size = {x, y}</dt>
<dd>Size of the button.
</dd>
<dt>Font = font-name</dt>
<dd>Name of the font to use.
</dd>
<dt>TextNormalColor = color, TextReverseColor = color</dt>
<dd>Color to use for the normal and reverse text.
</dd>
<dt>TextAlign = align</dt>
<dd>Align the text.  Possible values are "Left", "Right", and "Center".
</dd>
<dt>TextPos = {posx, posy}</dt>
<dd>Set the position of the text relative to the upper left corner of the image.
</dd>
<dt>Default = {tag = value, ...}, Hover = {}, Selected = {}, Clicked = {}, Disabled = {}</dt>
<dd>Set attributes for when the mouse is over the button (Hover), the button is
Selected, Clicked, Disabled, or the Default setting. Possible tags:
  <dl>
  <dt>File = file</dt>
  <dd>The filename.
  </dd>
  <dt>Size = size</dt>
  <dd>The size of the image (only needed when using an image with multiple frames).
  </dd>
  <dt>Frame = frame</dt>
  <dd>Select the frame number from an image (only needed when using an image with multiple frames).
  </dd>
  <dt>TextNormalColor = color, TextReverseColor = color</dt>
  <dd>Color to use for the normal and reverse text (overrides the main colors).
  </dd>
  <dt>TextPos = {x, y}</dt>
  <dd>Display the text at this position (overrides the main position).
  </dd>
  <dt>Border = { Color = color, Size = size}</dt>
  <dd>Draw a border with the specified color and size.
  </dd>
  </dl>
</dd>
</dl>

<h4>Example</h4>
<pre>
DefineButtonStyle("main", {
  Size = {128, 20},
  Font = "game",
  TextNormalColor = "yellow",
  TextReverseColor = "white",
  TextAlign = "Center",
  TextPos = {64, 4},
  Default = {
    File = "ui/buttons_1.png", Size = {300, 144}, Frame = 4,
  },
  Hover = {
    TextNormalColor = "white",
  },
  Selected = {
    Border = {
      Color = {252, 252, 0}, Size = 1,
    },
  },
  Clicked = {
    File = "ui/buttons_1.png", Size = {300, 144}, Frame = 5,
    TextNormalColor = "white",
    TextPos = {66, 6},
  },
  Disabled = {
    File = "ui/buttons_1.png", Size = {300, 144}, Frame = 3,
    TextNormalColor = "grey",
    TextReverseColor = "grey",
  },
})
</pre>

<a name="DefineCursor"></a>
<h3>DefineCursor({tag = value, ...})</h3>

Define a cursor.

<dl>
<dt>Name = "ident"</dt>
<dd>Unique identifier of the cursor, used to reference it in config files and
during startup.
</dd>
<dt>Race = "race-name" or "any"</dt>
<dd>Race to use this cursor with or "any" to use with any race.
</dd>
</dl>
Possible tags:
<dl>
<dt>File = "icon-file"</dt>
<dd>Path to the image graphic.</dd>
<dt>HotSpot = {x, y}</dt>
<dd>Hot spot of the cursor in pixels. Relative to the sprite origin {0, 0}. The
hot spot of a cursor is the point to which Bos Wars refers in tracking the
cursor's position.
</dd>
<dt>Size = {width, height}</dt>
<dd>Size of the cursor in pixels.</dd>
<dt>Rate = millisecond</dt>
<dd>Rate of changing the frames if using an animated cursor. The "rate" tells
the engine how many milliseconds to hold each frame of the animation.
</dd>
</dl>

Note: Name, File and Size must be filled.

<h4>Example</h4>
<pre>
DefineCursor({
  Name = "cursor-cross",
  Race = "any",
  File = "ui/cursors/small_green_cross.png",
  HotSpot = {8,  8},
  Size = {18, 18}})
</pre>

<a name="DefineViewports"></a>
<h3>DefineViewports("mode", mode, "viewport", {mapx, mapy}, ...)</h3>

Define the viewports. Only used in savegames, but could be useful for
scenarios.

<dl>
<dt>"mode", number</dt>
<dd>Number corresponding to the viewport mode.  See the ViewportMode enum. FIXME</dd>
<dt>"viewport", {mapx, mapy}</dt>
<dd>X, Y coordinate of the map tile.
</dd>
</dl>

<h4>Example</h4>
<pre>
-- Defines the viewports to use mode 1 (split horizontal) with the first
-- viewport having map coordinates 82,31 and the second having coordinates 64,31.
DefineViewports("mode", 1, "viewport", {82, 31},
                           "viewport", {64, 31})
</pre>

<a name="SetGameCursor"></a>
<h3>SetGameCursor("cursor-ident")</h3>
Set the game cursor.
<dl>
<dt>"cursor-ident"</dt>
<dd>Unique identifier of the cursor.</dd>
</dl>

<h4>Example</h4>
<pre>
-- Set the game cursor to 'cursor-point'.
SetGameCursor("cursor-point")
</pre>

<a name="HandleCommandKey"></a>
<h3>HandleCommandKey("key", ctrl, alt, shift)</h3>

<p>The Lua script must define this function.  The engine calls it when
the user presses a key that the engine does not handle on its own, and
no menu is open.  The engine can call this function during the game,
in the map editor, or in the patch editor.  To handle different keys
in different situations, the Lua script can redefine this function
when the user enters or leaves an editor.</p>

<dl>
<dt>"key"</dt>
<dd>The name of the key that the user pressed; for example, "a" or
"escape".  The name does not depend on which the language the user
selected.</dd>
<dt>ctrl</dt>
<dd>true if the user pressed the Control key too, false if not.</dd>
<dt>alt</dt>
<dd>true if the user pressed the Alt key too, false if not.</dd>
<dt>shift</dt>
<dd>true if the user pressed the Shift key too, false if not.</dd>
<dt><i>RETURNS</i></dt>
<dd>true if HandleCommandKey handled the key, false if the engine
should try to handle the key in some other way.</dd>
</dl>

<h2>Variables</h2>

<a name="UI"></a>
<h3>UI</h3>

<p>This variable refers to an object that has at least the following properties:</p>

<dl>
  <dt>UI.ButtonPanel.ShowCommandKey = boolean</dt>
  <dd>Enable/disable the display of the command keys in buttons.</dd>
  <dt id="UI.ReverseFontColor">UI.ReverseFontColor = string</dt>
  <dd>The name of the font color generally used for highlighting
    in <a href="#text_formatting">text formatting</a>.
    The font color must be defined with
    <a href="#CFontColor.New">CFontColor:New</a>.</dd>
  <dt id="UI.Resources">UI.Resources = table</dt>
  <dd>How the engine displays the resource costs of a command.
    This table contains a <a href="#CCResourceInfo">CResourceInfo</a>
    instance for each type of resource.
    The indices of the table are resource type identifiers,
    i.e. integers between 0 and <a href="#MaxCosts">MaxCosts</a>-1
    (even though indices typically start from 1 in Lua).</dd>
</dl>

<p>Do not change the UI variable itself from Lua, even though the
engine may allow that.</p>

<h2>Types</h2>

<a name="CColor"></a>
<h3>CColor</h3>

<p>The CColor type represents an RGBA color.</p>

<p>In the following subsections, <var>color</var> denotes
a CColor instance.</p>

<h4>CColor([r], [g], [b], [a])</h4>

<p>Constructs a <a href="#CColor">CColor</a> instance with the
specified Red, Green, Blue, and Alpha component values.
All arguments are optional.</p>

<h4><var>color</var>.R</h4>

<p>The red component, between 0 and 255.</p>

<h4><var>color</var>.G</h4>

<p>The green component, between 0 and 255.</p>

<h4><var>color</var>.B</h4>

<p>The blue component, between 0 and 255.</p>

<h4><var>color</var>.A</h4>

<p>The alpha component, between 0 and 255.
Not premultiplied.</p>

<p>Currently, the engine ignores the alpha component
of all CColor instances that Lua code can access:</p>

<ul>
  <li><a href="#CFontColor.Colors"><var>fontColor</var>.Colors</a></li>
  <li>UI.ButtonPanel.AutoCastBorderColorRGB</li>
  <li>UI.CompletedBarColorRGB</li>
</ul>

<a name="CFontColor"></a>
<h3>CFontColor</h3>

<p>Each CFontColor instance represents a named set of colors for use
in <a href="#text_formatting">text formatting</a>.</p>

<p>In the following subsections, <var>fontColor</var> denotes
a CFontColor instance.</p>

<h4 id="CFontColor.Colors"><var>fontColor</var>.Colors</h4>

<p>An array of <a href="#CColor">CColor</a> instances.
There are <a href="#MaxFontColors">MaxFontColors</a> elements in the array.
The engine ignores the alpha component of these CColor instances.</p>

<h4 id="CFontColor.Get">CFontColor:Get("name")</h4>

<p>Finds a font color by name.
Returns a <a href="#CFontColor">CFontColor</a> instance if found.
If no such font color has been defined, which indicates a bug,
then this function returns nil instead.</p>

<h4 id="CFontColor.New">CFontColor:New("name")</h4>

<p>Finds a font color by name, or allocates a new one.
Returns a <a href="#CFontColor">CFontColor</a> instance.
If it is a new one, then its <a href="#CFontColor.Colors">Colors</a>
array is all black, so you should set that before you use the
font color in <a href="#text_formatting">text formatting</a>.</p>

<a name="MaxFontColors"></a>
<h4>MaxFontColors</h4>

<p>This constant integer is the number of elements in the
<a href="#CFontColor.Colors">Colors</a> array in CFontColor
instances.</p>

<a name="CResourceInfo"></a>
<h3>CResourceInfo</h3>

<p>In the <a href="#UI.Resources">UI.Resources</a> table,
  there is one CResourceInfo instance for each type of resource.
  These objects control how the engine displays the resource costs of
  a command.  Each CResourceInfo instance has the following properties:</p>

<dl>
  <dt>G</dt>
  <dd>The <a href="#CGraphic">CGraphic</a> instance
    that contains the resource icon.</dd>
  <dt>IconFrame</dt>
  <dd>The frame number of the resource icon within the graphic.
    See <a href="unittype.html#frame_numbers">Frame numbers and flipping</a>.</dd>
  <dt>IconX</dt>
  <dd><em>Obsolete since r8638 (2007-03-28):
      The coordinates are hardcoded.</em>
    The X coordinate of the resource icon on the screen,
    for resources held by the player.</dd>
  <dt>IconY</dt>
  <dd><em>Obsolete since r8638 (2007-03-28):
      The coordinates are hardcoded.</em>
    The Y coordinate of the resource icon on the screen,
    for resources held by the player.</dd>
  <dt>TextX</dt>
  <dd><em>Obsolete since r8638 (2007-03-28):
      The coordinates are hardcoded.</em>
    The X coordinate of the text that describes the amount
    of resource held by the player.</dd>
  <dt>TextY</dt>
  <dd><em>Obsolete since r8638 (2007-03-28):
      The coordinates are hardcoded.</em>
    The Y coordinate of the text that describes the amount
    of resource held by the player.</dd>
</dl>

<p>These properties can be accessed with expressions like
  <code>UI.Resources[EnergyCost].G</code>.</p>

<a name="CGraphic"></a>
<h3>CGraphic</h3>

<p>A CGraphic instance is a graphic image that can be loaded from a
  file and then displayed on the screen.</p>

<p>In the following subsections, <var>graphic</var> denotes
  a CGraphic instance.</p>

<h4 id="CGraphic.New">CGraphic:New("filename", [width], [height])</h4>

<p>Creates a CGraphic instance that refers to the specified image file,
  unless one exists already.</p>

<dl>
  <dt>"filename"</dt>
  <dd>The name of the file from which
    <a href="#CGraphic.Load">CGraphic::Load</a> will load the graphic.</dd>
  <dt>width</dt>
  <dd>The width of each frame in the graphic,
    or 0 (default) to use the whole graphic as just one frame.</dd>
  <dt>height</dt>
  <dd>The height of each frame in the graphic,
    or 0 (default) to use the whole graphic as just one frame.</dd>
  <dt><i>RETURNS</i></dt>
  <dd>A CGraphic instance that refers to the specified image file.
    If one had already been created, then CGraphic::New returns that
    and increments its reference count; otherwise, CGraphic::New
    creates a new CGraphic instance.
    In either case, <a href="#CGraphic.Free">CGraphic:Free</a>
    will have to be called.</dd>
</dl>

<h4 id="CGraphic.Free">CGraphic:Free(graphic)</h4>

<p>Decrements the reference count of a CGraphic instance,
  and frees it if the reference count becomes zero.</p>

<p>The reference counts of CGraphic instances are not currently
  connected to Lua garbage collection.  CGraphic:Free must be
  called explicitly.  If a CGraphic instance is used after it
  has been freed, the engine will probably crash.</p>

<dl>
  <dt>graphic</dt>
  <dd>The CGraphic instance that the method should free.</dd>
  <dt><i>RETURNS</i></dt>
  <dd>Nothing.</dd>
</dl>

<h4 id="CGraphic.Load"><var>graphic</var>:Load()</h4>

<p>Loads the graphic from the image file whose name was given
  to <a href="#CGraphic.New">CGraphic:New</a>, unless it has
  already been loaded.</p>

<dl>
  <dt>graphic</dt>
  <dd>The CGraphic instance that the method should load.</dd>
  <dt><i>RETURNS</i></dt>
  <dd>Nothing.</dd>
</dl>

<h4 id="CGraphic.Resize"><var>graphic</var>:Resize(width, height)</h4>

<p>Resizes the graphic to the specified size.
  Because <a href="#CGraphic.New">CGraphic:New</a> returns
  the same CGraphic instance when given the same file name,
  resizing can affect other uses of the same graphic.
  To prevent such problems, you should use this method
  only on graphics that are displayed in one place at a time
  and are always resized before use.</p>

<dl>
  <dt>graphic</dt>
  <dd>The CGraphic instance that the method should resize.</dd>
  <dt>width</dt>
  <dd>The new width of the graphic, in pixels.</dd>
  <dt>height</dt>
  <dd>The new height of the graphic, in pixels.</dd>
  <dt><i>RETURNS</i></dt>
  <dd>Nothing.</dd>
</dl>

<hr>
All trademarks and copyrights on this page are owned by their respective owners.
<address>(c) 2002-2010 by <a href="http://boswars.org">
The Bos Wars Project</a></address></body></html>

